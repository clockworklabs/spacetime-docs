# SpacetimeDB

> SpacetimeDB is a fully-featured relational database system that integrates
application logic directly within the database, eliminating the need for
separate web or game servers. It supports multiple programming languages,
including C# and Rust, allowing developers to write and deploy entire
applications as a single binary. It is optimized for high-throughput and low
latency multiplayer applications like multiplayer games.

Users upload their application logic to run inside SpacetimeDB as a WebAssembly
module. There are three main features of SpacetimeDB: tables, reducers, and
subscription queries. Tables are relational database tables like you would find
in a database like Postgres. Reducers are atomic, transactional, RPC functions
that are defined in the WebAssembly module which can be called by clients.
Subscription queries are SQL queries which are made over a WebSocket connection
which are initially evaluated by SpacetimeDB and then incrementally evaluated
sending changes to the query result over the WebSocket.

All data in the tables are stored in memory, but are persisted to the disk via a
Write-Ahead Log (WAL) called the Commitlog. All tables are persistent in
SpacetimeDB.

SpacetimeDB allows users to code generate type-safe client libraries based on
the tables, types, and reducers defined in their module. Subscription queries
allows the client SDK to store a partial, live updating, replica of the servers
state. This makes reading database state on the client extremely inexpensive.

Authentication is implemented in SpacetimeDB using the OpenID Connect protocol.
An OpenID Connect token with a valid `iss`/`sub` pair constitutes a unique and
authenticable SpacetimeDB identity. SpacetimeDB uses the `Identity` type as an
identifier for all such identities. `Identity` is computed from the `iss`/`sub`
pair. This allows SpacetimeDB to easily integrate with OIDC authentication
providers like FirebaseAuth, Auth0, or SuperTokens.

Clockwork Labs, the developers of SpacetimeDB, offers three products:

1. SpacetimeDB Standalone: a source available (Business Source License), single node, self-hosted version
2. SpacetimeDB Maincloud: a hosted, managed-service, serverless cluster
3. SpacetimeDB Enterprise: a closed-source, clusterized version of SpacetimeDB which can be licensed for on-prem hosting or dedicated hosting

## Basic Project Workflow

Getting started with SpacetimeDB involves a few key steps:

1.  **Install SpacetimeDB:** Install the `spacetime` CLI tool for your operating system. This tool is used for managing modules, databases, and local instances.

    *   **macOS:**
        ```bash
        curl -sSf https://install.spacetimedb.com | sh
        ```
    *   **Windows (PowerShell):**
        ```powershell
        iwr https://windows.spacetimedb.com -useb | iex
        ```
    *   **Linux:**
        ```bash
        curl -sSf https://install.spacetimedb.com | sh
        ```
    *   **Docker (to run the server):**
        ```bash
        # This command starts a SpacetimeDB server instance in Docker
        docker run --rm --pull always -p 3000:3000 clockworklabs/spacetime start 
        # Note: The CLI still needs to be installed separately via one of the methods above 
        # to manage modules and interact with the Docker instance.
        ```
    *   For more details or troubleshooting, see the official [Getting Started Guide](https://spacetimedb.com/docs/getting-started) and [Installation Page](https://spacetimedb.com/install).

2.  **Initialize Server Module:** Create a new directory for your project and use the CLI to initialize the server module structure:
    ```bash
    # For Rust
    spacetime init --lang rust my_server_module
    # For C#
    spacetime init --lang csharp my_server_module
    ```
    :::note C# Project Filename Convention (SpacetimeDB CLI)
    The `spacetime` CLI tool (particularly `publish` and `build`) follows a convention and often expects the C# project file (`.csproj`) to be named `StdbModule.csproj`, matching the default generated by `spacetime init`. This appears to be a requirement of the SpacetimeDB tool itself, not the underlying .NET build system. If you encounter issues where the build succeeds but publishing fails (e.g., "couldn't find the output file" or silent failures after build), ensure your `.csproj` file is named `StdbModule.csproj` within your module's directory.
    :::
3.  **Define Schema & Logic:** Edit the generated module code (`lib.rs` for Rust, `Lib.cs` for C#) to define your custom types (`[SpacetimeType]`/`[Type]`), database tables (`#[table]`/`[Table]`), and reducers (`#[reducer]`/`[Reducer]`).
4.  **Build Module:** Compile your module code into WebAssembly using the CLI:
    ```bash
    # Run from the directory containing your module folder
    spacetime build --project-path my_server_module 
    ```
    :::note C# Build Prerequisite (.NET SDK)
    Building a **C# module** (on any platform: Windows, macOS, Linux) requires the .NET SDK to be installed. If the build fails with an error mentioning `dotnet workload list` or `No .NET SDKs were found`, you need to install the SDK first. Download and install **.NET 8 SDK** (or newer) from the official Microsoft website: [https://dotnet.microsoft.com/download](https://dotnet.microsoft.com/download).
    :::
5.  **Publish Module:** Deploy your compiled module to a SpacetimeDB instance (either a local one started with `spacetime start` or the managed Maincloud). Publishing creates or updates a database associated with your module.
    ```bash
    # Publish to a local instance or Maincloud, giving it a name
    spacetime publish --project-path my_server_module my_database_name
    ```
6.  **Generate Client Bindings:** Create type-safe client code based on your module's definitions.
    This command inspects your compiled module's schema (tables, types, reducers) and generates corresponding code (classes, structs, functions) for your target client language. This allows you to interact with your SpacetimeDB module in a type-safe way on the client.
    ```bash
    # For Rust client (output to src/module_bindings)
    spacetime generate --lang rust --out-dir path/to/client/src/module_bindings --project-path my_server_module
    # For C# client (output to module_bindings directory)
    spacetime generate --lang csharp --out-dir path/to/client/module_bindings --project-path my_server_module
    ```
7.  **Develop Client:** Create your client application (e.g., Rust binary, C# console app, Unity game). Use the generated bindings and the appropriate client SDK to:
    *   Connect to the database (`my_database_name`).
    *   Subscribe to data in public tables.
    *   Register callbacks to react to data changes.
    *   Call reducers defined in your module.
8.  **Run:** Start your SpacetimeDB instance (if local or Docker), then run your client application.

## Core Concepts and Syntax Examples

### Server Module (Rust)

#### Defining Types

Any custom struct or enum used as a field in a table or as a parameter/return type in a reducer must derive `SpacetimeType`. This allows SpacetimeDB to serialize and deserialize the type.

Use `#[sats(name = "...")]` to explicitly control the type name exposed to other languages (like C#) through generated bindings. This is useful for namespacing or avoiding conflicts.

```rust
use spacetimedb::{SpacetimeType, Identity, Timestamp};

#[derive(SpacetimeType, Clone, Debug, PartialEq)]
pub struct Position {
    pub x: i32,
    pub y: i32,
}

#[derive(SpacetimeType, Clone, Debug, PartialEq)]
pub enum PlayerStatus {
    Idle,
    Walking(Position),
    Fighting(Identity), // Store the identity of the opponent
}

// Specify a cross-language name for the enum itself and one variant
#[derive(SpacetimeType, Clone, Debug, PartialEq)]
#[sats(name = "Game.ItemType")] // Will be Game.ItemType in C# bindings
pub enum ItemType {
    Weapon,
    Armor,
    #[sats(name = "ConsumableItem")] // This variant will be ConsumableItem in C#
    Potion,
}

// Type aliases can be defined using `pub type`
pub type PlayerScore = u32;

// Advanced: For types with lifetimes or custom binary representations,
// you can derive `spacetimedb::Deserialize` and use the `bsatn` crate
// (provided by spacetimedb::spacetimedb_lib) for manual deserialization if needed.
```

:::info Rust `crate-type = ["cdylib"]`
The `[lib]` section in your module's `Cargo.toml` must contain `crate-type = ["cdylib"]`. This tells the Rust compiler to produce a dynamic system library compatible with the C ABI, which allows the SpacetimeDB host (written in Rust) to load and interact with your compiled WebAssembly module.
:::

#### Defining Tables

Tables store the application's data. They are defined using Rust structs annotated with `#[table]`.
This attribute automatically derives `Serialize`, `Deserialize`, `SpacetimeType`, and `Debug` for the struct.

Importantly, instances of the table struct are just plain data. Modifying a struct instance **does not** automatically update the database. Instead, you interact with the database tables through generated handles obtained from the `ReducerContext` (e.g., `ctx.db.my_table()`).

Fields can be marked with `#[primary_key]`, `#[auto_inc]`, `#[unique]`, or indexed using `#[index(...)]` or `#[table(index(...))]`.
Use `Option<T>` for nullable fields.

:::caution Important: Public Tables
By default, tables are **private** and only accessible by server-side reducer code. If clients need to read or subscribe to a table's data, you **must** mark the table as `public` using `#[table(..., public)]`.

*Common Pitfall:* If your client subscriptions fail with "table not found" or "not a valid table" errors, or if subscribed tables appear empty on the client despite having data on the server, double-check that the relevant tables are marked `public`.
:::

:::caution Case Sensitivity
The `name = "..."` specified in the `#[table(...)]` attribute is case-sensitive. When referring to this table in SQL queries (e.g., in client-side `subscribe` calls), you **must** use the exact same casing.

*Example:* If defined as `#[table(name = "PlayerState")]`, querying `SELECT * FROM player_state` will fail. You must use `SELECT * FROM PlayerState`.
:::

:::danger `#[auto_inc]` + `#[unique]` Pitfall
Be cautious when manually inserting rows into a table that uses both `#[auto_inc]` and `#[unique]` on the same field. If you manually insert a row with a value for that field that is *larger* than the current internal sequence counter, the sequence will eventually increment to that manually inserted value. When it attempts to assign this value to a new row (inserted with 0), it will cause a unique constraint violation error (or panic with `insert()`). Avoid manually inserting values into auto-incrementing unique fields unless you fully understand the sequence behavior.
:::

```rust
use spacetimedb::{table, Identity, Timestamp, SpacetimeType};

// Assume Position, PlayerStatus, ItemType are defined as above

#[table(name = "player_state", public)]
// Define indexes directly in the table attribute or on fields
#[table(index(name = "idx_level_btree", btree(columns = [level])))]
pub struct PlayerState {
    #[primary_key]
    player_id: Identity,
    #[unique] // Player names must be unique
    name: String,
    conn_id: Option<ConnectionId>, // Store the connection ID when online
    health: u32,
    level: u16,
    position: Position,
    status: PlayerStatus,
    last_login: Option<Timestamp>, // Optional timestamp
}

#[table(name = "inventory_item", public)]
pub struct InventoryItem {
    #[primary_key]
    #[auto_inc] // Automatically generate unique IDs for items
    item_id: u64,
    owner_id: Identity,
    #[index(btree)] // Shorthand for single-column B-tree index on this field
    item_type: ItemType,
    quantity: u32,
}

// Example of a private table (not marked public)
#[table(name = "internal_game_data")]
struct InternalGameData {
    #[primary_key]
    key: String,
    value: String,
}
```

##### Multiple Tables from One Struct

You can use the same underlying data struct for multiple tables by defining wrapper structs.

```rust
use spacetimedb::{table, SpacetimeType, Identity};

// Define the core data structure
#[derive(SpacetimeType, Clone, Debug)]
pub struct CharacterInfo {
     #[primary_key]
     character_id: u64,
     name: String,
     level: u16,
}

// Define wrapper structs, each with its own table attribute
#[table(name = "active_characters")]
pub struct ActiveCharacter(CharacterInfo);

#[table(name = "deleted_characters")]
pub struct DeletedCharacter(CharacterInfo);

// Reducers would interact with ActiveCharacter or DeletedCharacter tables
// E.g., ctx.db.active_characters().insert(ActiveCharacter(info));
```

Alternatively, multiple `#[table(...)]` attributes can be applied directly to a single struct definition. This maps the same underlying type definition to multiple distinct tables:

```rust
use spacetimedb::{table, SpacetimeType, Identity, Timestamp};

// Define the core data structure once
// Apply multiple #[table] attributes to map it to different tables
#[derive(SpacetimeType, Clone, Debug)] // Mark as type if used elsewhere
#[table(name = "logged_in_players", public)]
#[table(name = "players_in_lobby", public)]
pub struct PlayerSessionData {
    #[primary_key]
    player_id: Identity,
    #[unique]
    #[auto_inc]
    session_id: u64,
    last_activity: Timestamp,
}

// Reducers would interact with the specific table handles:
// E.g., ctx.db.logged_in_players().insert(PlayerSessionData { ... });
// E.g., let lobby_player = ctx.db.players_in_lobby().player_id().find(&some_id);
```

##### Browsing Generated Table APIs

The `#[table]` macro generates specific accessor methods based on your table definition (name, fields, indexes, constraints). To see the exact API generated for your tables:

1.  Run `cargo doc --open` in your module project directory.
2.  This compiles your code and opens the generated documentation in your web browser.
3.  Navigate to your module's documentation. You will find:
    *   The struct you defined (e.g., `PlayerState`).
    *   A generated struct representing the table handle (e.g., `player_state__TableHandle`), which implements `spacetimedb::Table` and contains methods for accessing indexes and unique columns.
    *   A generated trait (e.g., `player_state`) used to access the table handle via `ctx.db.{table_name}()`.

Reviewing this generated documentation is the best way to understand the specific methods available for interacting with your defined tables and their indexes.

#### Defining Reducers

Reducers are functions that modify table data atomically. They are annotated
with `#[reducer]`. 

:::info Transactionality
Crucially, **every reducer call executes within a single, atomic database transaction.** If the reducer function completes successfully (returns `()` or `Ok(())`), all database modifications made within it are committed together. If the reducer fails (panics or returns `Err(...)`), the transaction is aborted, and **all database changes made during that specific call are automatically rolled back**, ensuring data consistency.
:::

Reducers operate within a sandbox and have limitations:
*   They cannot directly perform network I/O (e.g., using `std::net`).
*   They cannot directly access the filesystem (e.g., using `std::fs` or `std::io`).
*   External communication happens primarily through database table modifications (which clients can subscribe to) and logging (`log` crate).

Reducers *can* call other reducers defined within the same module. This is a direct function call, not a network request, and executes within the same database transaction.

```rust
use spacetimedb::{reducer, ReducerContext, Table, Identity, Timestamp, log};

#[table(name = "user", public)]
pub struct User { /* ... fields ... */ }
#[table(name = "message", public)]
pub struct Message { /* ... fields ... */ }

// Reducer to set a user's name
#[reducer]
pub fn set_name(ctx: &ReducerContext, name: String) -> Result<(), String> {
    let name = validate_name(name)?; // Basic validation
    if let Some(user) = ctx.db.user().identity().find(ctx.sender) {
        // Update the user's name
        ctx.db.user().identity().update(User { name: Some(name), ..user });
        Ok(())
    } else {
        Err("Cannot set name for unknown user".to_string())
    }
}

// Reducer to send a message
#[reducer]
pub fn send_message(ctx: &ReducerContext, text: String) -> Result<(), String> {
    let text = validate_message(text)?; // Basic validation
    log::info!("Received message: {}", text);
    // Insert the new message into the table
    ctx.db.message().insert(Message {
        sender: ctx.sender,
        text,
        sent: ctx.timestamp,
    });
    Ok(())
}

// Reducer called when a client connects
#[reducer(client_connected)]
pub fn client_connected(ctx: &ReducerContext) {
    if let Some(user) = ctx.db.user().identity().find(ctx.sender) {
        // Mark existing user as online
        ctx.db.user().identity().update(User { online: true, ..user });
    } else {
        // Insert a new user record for the new connection
        ctx.db.user().insert(User {
            name: None,
            identity: ctx.sender,
            online: true,
        });
    }
}

// Reducer called when a client disconnects
#[reducer(client_disconnected)]
pub fn client_disconnected(ctx: &ReducerContext) {
    if let Some(user) = ctx.db.user().identity().find(ctx.sender) {
        // Mark user as offline
        ctx.db.user().identity().update(User { online: false, ..user });
    } else {
        log::warn!("Disconnect event for unknown user: {:?}", ctx.sender);
    }
}

// Reducer called once when the module is loaded/database is created
#[reducer(init)]
pub fn initialize_database(ctx: &ReducerContext) {
    log::info!("Database Initializing! Module Identity: {}", ctx.identity());
    // Perform one-time setup, like inserting initial data if tables are empty
    if ctx.db.user().count() == 0 {
        // Add an admin user or default settings
    }
}

// Helper validation functions (example)
fn validate_name(name: String) -> Result<String, String> {
    if name.is_empty() { Err("Name cannot be empty".to_string()) } else { Ok(name) }
}

fn validate_message(text: String) -> Result<String, String> {
    if text.is_empty() { Err("Message cannot be empty".to_string()) } else { Ok(text) }
}

##### Error Handling: `Result` vs. Panic

Reducers can fail by returning `Err` or by panicking. Both methods trigger a transaction rollback.
*   **Returning `Err(E)**:** This is the preferred way to handle *expected* failures (e.g., invalid input, failed validation). The error message (`E` must implement `Display`) is propagated back to the calling client and can be observed in the `ReducerEventContext` status.
*   **Panicking:** This typically represents an *unexpected* or unrecoverable error (e.g., assertion failure, bug). While it also rolls back the transaction, the client might not receive a specific error message, potentially just seeing a generic failure or disconnection.

##### Lifecycle Reducers

Special reducers handle specific events:
*   `#[reducer(init)]`: Runs once when the module is first published **and** any time the database is manually cleared. Failure prevents publishing or clearing.
*   `#[reducer(client_connected)]`: Runs when any distinct client connection (e.g., WebSocket, HTTP call) is established. Failure disconnects the client. `ctx.connection_id` is guaranteed to be `Some(...)` within this reducer.
*   `#[reducer(client_disconnected)]`: Runs when any distinct client connection terminates. Failure is logged but does not prevent disconnection. `ctx.connection_id` is guaranteed to be `Some(...)` within this reducer.

These reducers cannot take arguments beyond `&ReducerContext`.

```rust
// Example init reducer was shown previously
#[reducer(client_connected)]
pub fn handle_connect(ctx: &ReducerContext) {
    log::info!("Client connected: {}", ctx.sender);
    // ... setup initial state for ctx.sender ...
}

#[reducer(client_disconnected)]
pub fn handle_disconnect(ctx: &ReducerContext) {
    log::info!("Client disconnected: {}", ctx.sender);
    // ... cleanup state for ctx.sender ...
}
```

#### Filtering and Deleting with Indexes

SpacetimeDB provides powerful ways to filter and delete table rows using B-tree indexes. The generated accessor methods accept various argument types:

*   **Single Value:** Pass a reference (`&T`) for the indexed column type.
*   **Ranges:** Use Rust's range syntax (`start..end`, `start..=end`, `..end`, `..=end`, `start..`). Values can be owned or references.
*   **Multi-Column Indexes:** Pass a tuple containing values or ranges for each indexed column. The types must match the column order in the index definition. You can filter on a prefix of the index columns.

```rust
#[table(name = "points", index(name = "idx_xy", btree(columns = [x, y])))]
pub struct Point { x: i64, y: i64 }
#[table(name = "items", index(btree(columns = [name])))]
pub struct Item { #[primary_key] id: u32, name: String }

#[reducer]
fn index_operations(ctx: &ReducerContext) {
    // Example: Find items named "Sword"
    for item in ctx.db.items().name().filter("Sword") {
        // ...
    }

    // Example: Delete points where x is between 5 (inclusive) and 10 (exclusive)
    let num_deleted = ctx.db.points().idx_xy().delete(5i64..10i64);
    log::info!("Deleted {} points", num_deleted);

    // Example: Find points where x = 3 and y >= 0
    for point in ctx.db.points().idx_xy().filter((3i64, 0i64..)) {
        // ...
    }

    // Example: Delete all points where x = 7 (filtering on index prefix)
    ctx.db.points().idx_xy().delete(7i64);

    // Using references
    let min_x = 100i64;
    let max_x = 200i64;
    for point in ctx.db.points().idx_xy().filter(&min_x..=&max_x) {
         // ...
    }
}
```

##### Using `try_insert()`

Instead of `insert()`, which panics or throws if a constraint (like a primary key or unique index violation) occurs, Rust modules can use `try_insert()`. This method returns a `Result<RowType, String>`, allowing you to gracefully handle potential insertion failures.

```rust
#[reducer]
pub fn try_add_item(ctx: &ReducerContext, name: String) {
    let new_item = Item { id: 0, name }; // Assume AutoInc PK
    match ctx.db.items().try_insert(new_item) {
        Ok(inserted_item) => {
            log::info!("Successfully inserted item with ID: {}", inserted_item.id);
        }
        Err(e) => {
            log::error!("Failed to insert item: {}", e);
            // Optionally return an error to the client
        }
    }
}
```

#### Scheduled Reducers (Rust)

Rust modules also support scheduled reducers. The mechanism involves defining a scheduling table similar to C#, but the specific annotations and API calls differ slightly.
The `spacetimedb::duration!` macro can be a convenient way to specify durations.

Refer to the [official Rust Module SDK documentation on docs.rs](https://docs.rs/spacetimedb/latest/spacetimedb/attr.reducer.html#scheduled-reducers) for detailed syntax and examples, including usage of the `duration!` macro (e.g., `duration!("5s").into()` to create a `ScheduleAt`).

##### Scheduled Reducer Details

*   **Best-Effort Scheduling:** Scheduled reducers run on a best-effort basis and may be slightly delayed under heavy database load.
*   **Security:** Since scheduled reducers can also be called directly by clients if not secured, it's crucial to verify the caller identity if the reducer performs sensitive operations:
    ```rust
    #[reducer]
    fn scheduled_task(ctx: &ReducerContext, args: MyScheduleTable) -> Result<(), String> {
        if ctx.sender != ctx.identity() {
            return Err("Permission denied: Task can only be run by scheduler.".into());
        }
        // ... proceed with scheduled logic ...
        Ok(())
    }
    ```

:::info Scheduled Reducers and Connections
Scheduled reducer calls originate from the SpacetimeDB scheduler itself, not from an external client connection. Therefore, within a scheduled reducer, `ctx.Sender` will be the module's own identity, and `ctx.ConnectionId` will not represent an external client connection.
:::

#### Row-Level Security (Client Visibility Filters)

(Unstable Feature)

SpacetimeDB allows defining row-level security rules using the `#[spacetimedb::client_visibility_filter]` attribute. This attribute is applied to a `const` binding of type `Filter` and defines an SQL-like query that determines which rows of a table are visible to clients making subscription requests.

*   The query uses `:sender` to refer to the identity of the subscribing client.
*   Multiple filters on the same table are combined with `OR` logic.
*   Query errors (syntax, type errors, unknown tables) are reported during `spacetime publish`.

```rust
use spacetimedb::{client_visibility_filter, Filter, table, Identity};

#[table(name = "location_state")]
struct LocationState { #[primary_key] entity_id: u64, chunk_index: u32 }
#[table(name = "user_state")]
struct UserState { #[primary_key] identity: Identity, entity_id: u64 }

/// Players can only see entities located in the same chunk as their own entity.
#[client_visibility_filter]
const PLAYERS_SEE_ENTITIES_IN_SAME_CHUNK: Filter = Filter::Sql("
    SELECT * FROM LocationState WHERE chunk_index IN (
        SELECT chunk_index FROM LocationState WHERE entity_id IN (
            SELECT entity_id FROM UserState WHERE identity = :sender
        )
    )
");
```

:::note Unstable Feature
As of the time of writing, this feature might be marked as unstable or not fully implemented/enforced by the SpacetimeDB host. Check the latest official documentation for current status.
:::

### Server Module (C#)

#### Defining Types

Custom classes, structs, or records used in tables or reducers must be marked with the `[Type]` attribute.
Use `partial` to allow code generation.
Tagged enums are represented using `TaggedEnum<(...)` with intermediate records defining variants.

```csharp
using SpacetimeDB;
using System.Collections.Generic;

[Type]
public partial struct Position { public int X; public int Y; }

// C# Tagged Enum Pattern using intermediate records:
[Type] public abstract partial record PlayerStatusBase { }
[Type] public partial record IdleStatus : PlayerStatusBase { }
[Type] public partial record WalkingStatus : PlayerStatusBase { public Position Target; }
[Type] public partial record FightingStatus : PlayerStatusBase { public Identity OpponentId; }

[Type]
public partial record PlayerStatus : TaggedEnum<(
    IdleStatus Idle,
    WalkingStatus Walking,
    FightingStatus Fighting
)> { }

[Type]
public enum ItemType { Weapon, Armor, Potion }

// Type aliases can be defined using the `using` directive
using PlayerScore = System.UInt32;

// Note: A [Sats(Name = "...")] attribute similar to Rust's for cross-language naming
// might not be fully supported or available in C# modules currently.
// Check latest SDK documentation for updates.
```

:::info C# `partial` Keyword
Table and Type definitions in C# should use the `partial` keyword (e.g., `public partial class MyTable`). This allows the SpacetimeDB source generator to add necessary internal methods and serialization logic to your types without requiring you to write boilerplate code.
:::

#### Defining Tables

Tables are defined using C# partial classes or structs annotated with `[Table]`.
Use `[PrimaryKey]`, `[AutoInc]`, `[Unique]`, and `[Index.BTree(...)]` attributes.
Use nullable types (`T?`) for optional fields.

:::caution Public Fields Required for Attributes
When using SpacetimeDB-specific attributes like `[PrimaryKey]`, `[AutoInc]`, `[Unique]`, or `[Index.BTree]` in C# table definitions, you **must** apply them to **public fields**, not C# properties (`{ get; set; }`). The SpacetimeDB code generator relies on direct field access for these attributes to function correctly. Using properties with these attributes can lead to build errors or unexpected runtime behavior.

Properties can generally be used for simple data fields that do not have these special SpacetimeDB attributes applied.
:::

:::caution Important: Public Tables
By default, tables are **private** and only accessible by server-side reducer code. If clients need to read or subscribe to a table's data, you **must** mark the table as `public` by setting `Public = true` in the `[Table]` attribute (e.g., `[Table(Name = "my_table", Public = true)]`).

*Common Pitfall:* If your client subscriptions fail with "table not found" or "not a valid table" errors, or if subscribed tables appear empty on the client despite having data on the server, double-check that the relevant tables have `Public = true` set in their `[Table]` attribute.
:::

:::caution Case Sensitivity
The `Name = "..."` specified in the `[Table(...)]` attribute is case-sensitive. When referring to this table in SQL queries (e.g., in client-side `subscribe` calls), you **must** use the exact same casing.

*Example:* If defined as `[Table(Name = "PlayerState")]`, querying `SELECT * FROM player_state` will fail. You must use `SELECT * FROM PlayerState`.
:::

:::caution Note on Modifying Instances
Instances of your table classes/structs are plain data objects. Modifying an instance **does not** automatically update the corresponding row in the database. You must explicitly call update methods (e.g., `ctx.Db.my_table.PrimaryKey.Update(modifiedInstance)`) to persist changes.
:::

:::danger `[AutoInc]` + `[Unique]` Pitfall (C#)
Be cautious when manually inserting rows into a table that uses both `[AutoInc]` and `[Unique]` on the same field. If you manually insert a row with a value for that field that is *larger* than the current internal sequence counter, the sequence will eventually increment to that manually inserted value. When it attempts to assign this value to a new row (inserted with 0), it will cause a unique constraint violation error (throwing an exception). Avoid manually inserting values into auto-incrementing unique fields unless you fully understand the sequence behavior.
:::

```csharp
using SpacetimeDB;
using System;

// Assume Position, PlayerStatus, ItemType are defined as above

[Table(Name = "player_state", Public = true)]
[Index.BTree(Name = "idx_level", Columns = new[] { nameof(Level) })] // Table-level index
public partial class PlayerState
{
    [PrimaryKey]
    public Identity PlayerId; // Field
    [Unique]
    public string Name = ""; // Field (initialize to avoid null warnings if Nullable enabled)
    public ConnectionId? ConnId; // Field
    public uint Health; // Field
    public ushort Level; // Field
    public Position Position; // Field
    public PlayerStatus Status; // Field
    public Timestamp? LastLogin; // Field
}

[Table(Name = "inventory_item", Public = true)]
public partial class InventoryItem
{
    [PrimaryKey]
    [AutoInc]
    public ulong ItemId; // Field
    public Identity OwnerId; // Field
    [Index.BTree] // Index on this field
    public ItemType ItemType; // Field
    public uint Quantity; // Field
}

// Example of a private table
[Table(Name = "internal_game_data")] // Public = false is default
public partial class InternalGameData
{
    [PrimaryKey]
    public string Key = ""; // Field
    public string Value = ""; // Field
}
```

##### Multiple Tables from One Class

You can use the same underlying data class for multiple tables, often using inheritance. Ensure SpacetimeDB attributes like `[PrimaryKey]` are applied to **public fields**, not properties.

```csharp
using SpacetimeDB;

// Define the core data structure (must be [Type] if used elsewhere)
[Type]
public partial class CharacterInfo
{
     [PrimaryKey]
     public ulong CharacterId; // Use public field
     public string Name = "";   // Use public field
     public ushort Level;      // Use public field
}

// Define derived classes, each with its own table attribute
[Table(Name = "active_characters")]
public partial class ActiveCharacter : CharacterInfo { 
    // Can add specific public fields if needed
    public bool IsOnline;
}

[Table(Name = "deleted_characters")]
public partial class DeletedCharacter : CharacterInfo { 
    // Can add specific public fields if needed
    public Timestamp DeletionTime;
}

// Reducers would interact with ActiveCharacter or DeletedCharacter tables
// E.g., ctx.Db.active_characters.Insert(new ActiveCharacter { CharacterId = 1, Name = "Hero", Level = 10, IsOnline = true });
```

Alternatively, you can define multiple `[Table]` attributes directly on a single class or struct. This maps the same underlying type to multiple distinct tables:

```csharp
using SpacetimeDB;

// Define the core data structure once
// Apply multiple [Table] attributes to map it to different tables
[Type] // Mark as a type if used elsewhere (e.g., reducer args)
[Table(Name = "logged_in_players", Public = true)]
[Table(Name = "players_in_lobby", Public = true)]
public partial class PlayerSessionData
{
    [PrimaryKey]
    public Identity PlayerId; // Use public field
    [Unique]
    [AutoInc]
    public ulong SessionId; // Use public field
    public Timestamp LastActivity;
}

// Reducers would interact with the specific table handles:
// E.g., ctx.Db.logged_in_players.Insert(new PlayerSessionData { ... });
// E.g., var lobbyPlayer = ctx.Db.players_in_lobby.PlayerId.Find(someId);
```

#### Defining Reducers

Reducers are static methods annotated with `[SpacetimeDB.Reducer]`. Lifecycle reducers use `ReducerKind`.

:::info Transactionality
Crucially, **every reducer call executes within a single, atomic database transaction.** If the reducer method completes successfully without throwing an unhandled exception, all database modifications made within it are committed together. If the reducer fails by throwing an unhandled exception, the transaction is aborted, and **all database changes made during that specific call are automatically rolled back**, ensuring data consistency.
:::

:::info Reducer Environment
*   **Sandbox:** Reducers run in a restricted environment. They cannot directly perform network I/O or access the local filesystem.
*   **External Interaction:** Communication with the outside world is done by modifying database tables (which clients can subscribe to) or through logging (`SpacetimeDB.Log`).
*   **Calling Other Reducers:** Reducers can call other static methods within the module, including other reducers. Such calls execute within the same database transaction.
:::

```csharp
using SpacetimeDB;
using System;
using System.Linq;

public static partial class Module
{
    // Assume PlayerState, InventoryItem tables and Position, PlayerStatus types are defined

    // Example Reducer showing various operations
    [Reducer]
    public static void UpdatePlayerData(ReducerContext ctx, string? newName)
    {
        var playerId = ctx.Sender;

        // 1. Find a player by primary key
        var player = ctx.Db.player_state.PlayerId.Find(playerId);
        if (player == null)
        {
            throw new Exception($"Player not found: {playerId}");
        }

        // 2. Update fields
        if (!string.IsNullOrWhiteSpace(newName))
        {
            // Check for uniqueness using the unique index accessor
            var existingPlayerWithNewName = ctx.Db.player_state.Name.Find(newName);
            if (existingPlayerWithNewName != null && existingPlayerWithNewName.PlayerId != playerId)
            {
                 throw new Exception($"Name already taken: {newName}");
            }
            player.Name = newName;
        }
        player.Level += 1;

        // 3. Update the row using the primary key index
        ctx.Db.player_state.PlayerId.Update(player);
        Log.Info($"Updated player data for {playerId}");
    }

    // Example: Handling Insert Exceptions
    [Reducer]
    public static void RegisterPlayer(ReducerContext ctx, string name)
    {
        if (string.IsNullOrWhiteSpace(name)) {
             throw new ArgumentException("Name cannot be empty.");
        }
        Log.Info($"Attempting to register player: {name}");

        // Check if player already exists (by PK or unique name)
        if (ctx.Db.player_state.PlayerId.Find(ctx.Sender) != null || ctx.Db.player_state.Name.Find(name) != null)
        {
             throw new Exception("Player already registered or name taken.");
        }

        var newPlayer = new PlayerState
        {
            PlayerId = ctx.Sender,
            Name = name,
            Health = 100,
            Level = 1,
            Position = new Position { X = 0, Y = 0 },
            Status = PlayerStatus.Idle(new IdleStatus()),
            LastLogin = ctx.Timestamp,
        };

        // Insert will throw an exception if constraints (PK, Unique) are violated
        // A try-catch block could handle this, but checking first is often cleaner.
        try {
            ctx.Db.player_state.Insert(newPlayer);
            Log.Info($"Player registered successfully: {ctx.Sender}");
        } catch (Exception ex) {
            // This might catch more than just constraint violations
            Log.Error($"Failed to register player {ctx.Sender}: {ex.Message}");
            throw; // Re-throw to ensure transaction rollback
        }
    }

    // Example: Filtering and Deleting with Indexes
    [Reducer]
    public static void CleanupLowLevelItems(ReducerContext ctx, ushort maxLevelToKeep)
    {
        var owner = ctx.Sender;
        var playerLevel = ctx.Db.player_state.PlayerId.Find(owner)?.Level ?? 0;

        if (playerLevel > maxLevelToKeep)
        {
            Log.Info($"Player level {playerLevel} exceeds threshold {maxLevelToKeep}. Cleaning up items...");

            // Get items owned by the player
            // Note: Filtering directly by OwnerId requires an index on that field.
            // If no index, iterate and filter manually.
            var itemsToCheck = ctx.Db.inventory_item.Iter()
                                    .Where(item => item.OwnerId == owner)
                                    // .Where(item => item.LevelRequirement < maxLevelToKeep) // Assuming LevelRequirement exists
                                    .ToList(); // Collect to avoid modifying while iterating

            uint deletedCount = 0;
            foreach (var item in itemsToCheck)
            {
                 // Add logic here based on ItemType or other properties if needed
                 Log.Info($"Deleting item ID: {item.ItemId} for owner {owner}");
                 // Delete using the primary key index accessor
                 if (ctx.Db.inventory_item.ItemId.Delete(item.ItemId))
                 {
                     deletedCount++;
                 }
            }
            Log.Info($"Deleted {deletedCount} low-level items for player {owner}");
        }
    }

    // Example: Interacting with a Private Table
    [Reducer]
    private static void UpdateInternalData(ReducerContext ctx, string key, string value)
    {
        // Example of a private helper reducer, possibly called by another reducer.
        // Assume InternalGameData table exists (defined as private)

        var data = ctx.Db.internal_game_data.Key.Find(key);
        if (data != null)
        {
            data.Value = value;
            ctx.Db.internal_game_data.Key.Update(data);
            Log.Info($"Updated internal key: {key}");
        }
        else
        {
            ctx.Db.internal_game_data.Insert(new InternalGameData { Key = key, Value = value });
            Log.Info($"Inserted internal key: {key}");
        }
    }

    // Example: Getting Table Row Count
    [Reducer]
    public static void CountPlayers(ReducerContext ctx)
    {
        var count = ctx.Db.player_state.Count; // Use the Count property
        Log.Info($"Current player count: {count}");
    }

    // Example: Timestamp/Duration Calculation
    [Reducer]
    public static void CheckLastLogin(ReducerContext ctx)
    {
        var player = ctx.Db.player_state.PlayerId.Find(ctx.Sender);
        if (player != null && player.LastLogin.HasValue)
        {
            TimeSpan? durationSinceLogin = ctx.Timestamp.TimeDurationSince(player.LastLogin.Value);
            if (durationSinceLogin.HasValue)
            {
                 Log.Info($"Player {ctx.Sender} last logged in {durationSinceLogin.Value} ago.");
            }
            else
            {
                 Log.Warn($"Player {ctx.Sender} last login time is in the future?");
            }
        }
        else if (player != null)
        {
             Log.Info($"Player {ctx.Sender} has no recorded login time.");
        }
    }

    // Example: Filtering and Deleting with Indexes
    [Reducer]
    public static void IndexOperations(ReducerContext ctx)
    {
        // Example: Find items named "Sword"
        var items = ctx.Db.items.name.Filter("Sword");
        foreach (var item in items) { /* ... */ }

        // Example: Delete points where x is 5
        bool deleted = ctx.Db.points.idx_xy.Delete(5L); // Filter on index prefix

        // Example: Find points where x = 3 and y = 7
        var specificPoint = ctx.Db.points.idx_xy.Filter((3L, 7L));
        foreach(var pt in specificPoint) { /* ... should be at most one */}

        // Example: Find points where x is between 100 and 200 (inclusive)
        var pointsInRange = ctx.Db.points.idx_xy.Filter((100L, 200L));
        foreach(var pt in pointsInRange) { /* ... */ }

        // Example: Delete items named "Shield"
        uint numDeleted = ctx.Db.items.name.Delete("Shield");
        Log.Info($"Deleted {numDeleted} Shield(s)");
    }
}
```

:::note C# `Insert` vs Rust `try_insert`
Unlike Rust, the C# SDK does not currently provide a `TryInsert` method that returns a result. The standard `Insert` method will throw an exception if a constraint (primary key, unique index) is violated. Therefore, C# reducers should typically check for potential constraint violations *before* calling `Insert`, or be prepared to handle the exception (which will likely roll back the transaction).
:::

##### Module Identity vs Sender Identity

Inside a reducer, the `ReducerContext` provides two important identities:

*   `ctx.Sender`: The [`Identity`](#identity) of the client who called the reducer, or the identity of the module itself if the reducer was called by the scheduler (for scheduled reducers) or internally by another reducer.
*   `ctx.Identity`: The [`Identity`](#identity) of the module (database) itself.
*   `ctx.Timestamp`: A [`Timestamp`](#timestamp) indicating when the reducer execution began.
*   `ctx.ConnectionId`: A [`ConnectionId`](#connectionid) representing the specific connection that invoked the reducer. This is a large (u128-based), randomly generated identifier **assigned by the SpacetimeDB server** for each distinct client connection (e.g., a WebSocket session or a stateless HTTP call). It is unique for the duration of that connection instance (from `client_connected` to `client_disconnected`). Unlike `ctx.Sender` (the authenticated [`Identity`](#identity)), the `ConnectionId` is **not verified** based on client input; it solely identifies the server-side connection object. Use `ConnectionId` for logic specific to a *transient connection* (e.g., tracking session state, rate limiting) and `Sender` (`Identity`) for logic tied to the *persistent, authenticated user account*.

This distinction is crucial for security, especially with scheduled reducers. You often want to ensure that only the scheduler (i.e., the module itself) can trigger certain actions.

##### Lifecycle Reducers

Special reducers handle specific events:
*   `[Reducer(ReducerKind.Init)]`: Runs once when the module is first published **and** any time the database is manually cleared. Failure prevents publishing or clearing.
*   `[Reducer(ReducerKind.ClientConnected)]`: Runs when any distinct client connection (e.g., WebSocket, HTTP call) is established. Failure disconnects the client. `ctx.ConnectionId` is guaranteed to have a value within this reducer.
*   `[Reducer(ReducerKind.ClientDisconnected)]`: Runs when any distinct client connection terminates. Failure is logged but does not prevent disconnection. `ctx.ConnectionId` is guaranteed to have a value within this reducer.

These reducers cannot take arguments beyond `ReducerContext`.

```csharp
// Example init reducer is shown in Scheduled Reducers section
[Reducer(ReducerKind.ClientConnected)]
public static void HandleConnect(ReducerContext ctx) {
    Log.Info($"Client connected: {ctx.Sender}");
    // ... setup initial state for ctx.sender ...
}

[Reducer(ReducerKind.ClientDisconnected)]
public static void HandleDisconnect(ReducerContext ctx) {
    Log.Info($"Client disconnected: {ctx.Sender}");
    // ... cleanup state for ctx.sender ...
}
```

#### Filtering and Deleting with Indexes

SpacetimeDB provides powerful ways to filter and delete table rows using B-tree indexes. The generated accessor methods accept various argument types:

*   **Single Value:** Pass a reference (`&T`) for the indexed column type.
*   **Ranges:** Use Rust's range syntax (`start..end`, `start..=end`, `..end`, `..=end`, `start..`). Values can be owned or references.
*   **Multi-Column Indexes:** Pass a tuple containing values or ranges for each indexed column. The types must match the column order in the index definition. You can filter on a prefix of the index columns.

```csharp
using SpacetimeDB;
using System;
using System.Linq;

public static partial class Module
{
    // Example: Filtering and Deleting with Indexes
    [Reducer]
    public static void IndexOperations(ReducerContext ctx)
    {
        // Example: Find items named "Sword"
        var items = ctx.Db.items.name.Filter("Sword");
        foreach (var item in items) { /* ... */ }

        // Example: Delete points where x is 5
        bool deleted = ctx.Db.points.idx_xy.Delete(5L); // Filter on index prefix

        // Example: Find points where x = 3 and y = 7
        var specificPoint = ctx.Db.points.idx_xy.Filter((3L, 7L));
        foreach(var pt in specificPoint) { /* ... should be at most one */}

        // Example: Find points where x is between 100 and 200 (inclusive)
        var pointsInRange = ctx.Db.points.idx_xy.Filter((100L, 200L));
        foreach(var pt in pointsInRange) { /* ... */ }

        // Example: Delete items named "Shield"
        uint numDeleted = ctx.Db.items.name.Delete("Shield");
        Log.Info($"Deleted {numDeleted} Shield(s)");
    }
}
```

:::note C# `Insert` vs Rust `try_insert`
Unlike Rust, the C# SDK does not currently provide a `TryInsert` method that returns a result. The standard `Insert` method will throw an exception if a constraint (primary key, unique index) is violated. Therefore, C# reducers should typically check for potential constraint violations *before* calling `Insert`, or be prepared to handle the exception (which will likely roll back the transaction).
:::

##### Scheduled Reducer Details

*   **Best-Effort Scheduling:** Scheduled reducers run on a best-effort basis and may be slightly delayed under heavy database load.
*   **Security:** Since scheduled reducers can also be called directly by clients if not secured, it's crucial to verify the caller identity if the reducer performs sensitive operations:
    ```csharp
    [Reducer]
    public static void ScheduledTask(ReducerContext ctx, GameTickSchedule args) // Use the actual schedule table type
    {
        if (!ctx.Sender.Equals(ctx.Identity))
        {
            throw new Exception("Permission denied: Task can only be run by scheduler.");
        }
        // ... proceed with scheduled logic ...
        Log.Info($"Executing scheduled task for tick {args.TickNumber}");
    }
    ```

##### Error Handling: Exceptions

Throwing an unhandled exception within a C# reducer will cause the transaction to roll back.
*   **Expected Failures:** For predictable errors (e.g., invalid arguments, state violations), explicitly `throw` an `Exception`. The exception message can often be observed by the client in the `ReducerEventContext` status (though the exact behavior might vary).
*   **Unexpected Errors:** Unhandled runtime exceptions (e.g., `NullReferenceException`) also cause rollbacks but might provide less informative feedback to the client, potentially just indicating a general failure.

It's generally good practice to validate input and state early in the reducer and `throw` specific exceptions for handled error conditions.

### Client SDK (Rust)

fn on_message_sent_result(ctx: &ReducerEventContext, text: &String) {
    if let Status::Failed(err) = &ctx.event.status {
        eprintln!("[Error] Failed to send message '{}': {}", text, err);
    }
}

:::info Handling Initial Data vs. Live Updates in Callbacks
Callbacks like `on_insert` and `on_update` are triggered for both the initial data received when a subscription is first applied *and* for subsequent live changes caused by reducers. If you need to differentiate (e.g., only react to *new* messages, not the backlog), you can inspect the `ctx.event` type. For example, `if let Event::Reducer(_) = ctx.event { ... }` checks if the change came from a reducer call.
:::

:::info Handling Initial Data vs. Live Updates in Callbacks
Callbacks like `OnInsert` and `OnUpdate` are triggered for both the initial data received when a subscription is first applied *and* for subsequent live changes caused by reducers. If you need to differentiate (e.g., only react to *new* messages, not the backlog), you can inspect the `ctx.Event` type. For example, checking `if (ctx.Event is not Event<Reducer>.SubscribeApplied) { ... }` ensures the code only runs for events triggered by reducers, not the initial subscription data load.
:::